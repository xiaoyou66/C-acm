## 时间复杂度分析
//----------------------------------

题目描述
分析如下代码
for(i=1;i<n;i++)
  for(j=1;j<i;j++)
    for(k=1;k<j;k++)
      printf("\n");
问printf语句共执行了几次？这段代码执行完以后i+j+k值为多少？


输入
由多行组成，每行一个整数n, 1<= n <= 3000

输出
对每一行输入，输出对应的一行，包括空格分开的两个整数，分别代表printf语句的执行次数以及代码执行完以后i+j+k的值, 如果值不确定,输出"RANDOM"取代值的位置


样例输入
6

样例输出
10 15

//----------------

正常情况下我们是直接自己写代码实验，实际上，这样做会超时，我们需要智取
```
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,k,sum=0;
	while(scanf("%d",&n)!=-1)
	{
		printf("%lld",((long long)(n-1)*(n-2)*(n-3)/6));
		if(n>2)
			printf(" %d\n",3*n-3);
		else 
			printf(" RANDOM\n");
	}
	return 0;
}
```
我们这里可以发现，上面那个三层的for循环可以先看成两次循环。
```
for(i=1;i<n;i++)
  for(j=1;j<i;j++)
    cnt+=j-1;
```
这里的时间复杂度变成了n*n

但是还是会超时，我们可以在简化一下
```
for(i=1;i<n;i++)
    cnt+=(i-1)*(i-2)/2;//实际上可以看成   加了i-1次每次加的是i-2
```

